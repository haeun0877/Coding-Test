큰 수의 법칙
---

**입력조건**
* 첫쨰 줄에 N, M, K의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
* 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
* 입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력조건**
* 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

-큰 수의 법칙 : ex) N = 2,4,5,4,6 , M = 8, K =3 일때 결과는 6+6+6+5+6+6+6+5=46 으로 46이 된다.

**나의 풀이**

알고리즘 : 리스트를 입력받은 후 내림차순으로 정렬한후 k값만큼 0번째 수를 더하고 k보다 더 많이 입력했을때는 1번째 수를 더하고 다시 k값만큼 0 번쨰 수를 더하는 것을 반복한다.
```
n, m, k = map(int,input().split())
arr = list(map(int,input().split()))
arr.sort(reverse=True)
sum=0
num=1

for i in range(m):
  if num>k:
    sum+=arr[1]
    num=1
    continue
  sum+=arr[0]
  num+=1

print(sum)
```

**책의 풀이**

* 알고리즘1 : 나의 풀이 알고리즘과 동일
* 알고리즘2 : 시간초과 판정을 피할 수 있는 알고리즘 = 가장 큰 수가 더해지는 횟수 = **int(M/(K+1))*K+M%(K+1)** 를 이용하여 가장 큰 수가 더해지는 횟수를 구한다음, 이를 이용해 두번째로 큰 수가 더해지는 횟수까지 구한다.

=반복되는 수열의 길이 = (K+1), 따라서 M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수, 다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수

=이때 M이 (K+1)로 나누어 떨어지지않는 경우도 고려하여 M을 (K+1)로 나눈 나머지만큼 가장 큰수가 추가로 더해지므로 이를 고려해주어

 = **int(M/(K+1))*K+M%(K+1)** 의 식이 나온다

```

