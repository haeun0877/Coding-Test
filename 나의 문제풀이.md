큰 수의 법칙
---

**입력조건**
* 첫쨰 줄에 N, M, K의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
* 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
* 입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력조건**
* 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.
 
-큰 수의 법칙 : ex) N = 2,4,5,4,6 , M = 8, K =3 일때 결과는 6+6+6+5+6+6+6+5=46 으로 46이 된다.

**나의 풀이**

알고리즘 : 리스트를 입력받은 후 내림차순으로 정렬한후 k값만큼 0번째 수를 더하고 k보다 더 많이 입력했을때는 1번째 수를 더하고 다시 k값만큼 0 번쨰 수를 더하는 것을 반복한다.
```
n, m, k = map(int,input().split())
arr = list(map(int,input().split()))
arr.sort(reverse=True)
sum=0
num=1

for i in range(m):
  if num>k:
    sum+=arr[1]
    num=1
    continue
  sum+=arr[0]
  num+=1

print(sum)
```

**책의 풀이**

* 알고리즘1 : 나의 풀이 알고리즘과 동일
* 알고리즘2 : 시간초과 판정을 피할 수 있는 알고리즘 = 가장 큰 수가 더해지는 횟수 = int(M/(K+1))*K+M%(K+1) 를 이용하여 가장 큰 수가 더해지는 횟수를 구한다음, 이를 이용해 두번째로 큰 수가 더해지는 횟수까지 구한다.

=반복되는 수열의 길이 = (K+1), 따라서 M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수, 다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수

=이때 M이 (K+1)로 나누어 떨어지지않는 경우도 고려하여 M을 (K+1)로 나눈 나머지만큼 가장 큰수가 추가로 더해지므로 이를 고려해int(M/(K+1))*K+M%(K+1) 의 식이 나온다

```
n, m, k = map(int, input().split())
data=list(map(int,input().split()))

data.sort()
first=data[n-1]
second=data[n-2]

count = int(m/(k+1))*k
count+=m%(k+1)

result = 0
result+=(count)*first
result+=(m-count)*second

print(result)
```

* * *

숫자 카드 게임
---

**입력조건**
* 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어짐
* 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어짐
* 첫째 줄에 게임의 룰에 맞게 선택한 가드에 적힌 숫자를 출력한다
* 행을 선택하고 그 선택된 행에 포함된 카드중 가장 숫자가 낮은 카드를 뽑는다
* 결과적으로 가장 높은 숫자가 나올수 있는 행을 출력하는 프로그램

**나의 풀이**
알고리즘 : 행별로 각각 가장 낮은 숫자를 고르고 그 숫자들끼리 비교하여 가장 큰 수를 뽑고 그 수의 행을 찾는다. min()함수 사용
```
n, m = map(int, input().split())
minD=0
maxD=0

for i in range(n):
  data = list(map(int, input().split()))
  minD=min(data)
  if minD>maxD:
    maxD=minD

print(maxD)
```

**책의 풀이**
알고리즘1 : min()함수사용 (동일) (max를 비교할때도 max()함수 사용)
알고리즘2 : 2중 반복문 구조를 이용

```
n, m = map(int, input().split())
result=0

for i in range(n):
  data = list(map(int, input().split()))
  min_value=10001
  for a in data:
    min_value = min(min_value, a)
  result = max(result, min_value)

print(result)
```
* * *

1이 될 때까지
---

**입력조건**
* 첫째 줄에 N과 K가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로는 N은 항상 K보다 크거나 같다.
* 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값 출력
* 1. N에서 1을 뺀다. 2. N을 K로 나눈다.

**나의 풀이**
알고리즘 : N을 K로 나누는 횟수를 최대한 많게하기 위해 -1을 사용하여 N을 K의 배수가 되도록한다.
```
n, k = map(int, input().split())
result=n
num=0

while True:
  num+=1
  if result%k==0:
    result//=k
  else :
    result-=1
  if result==1:
    break;

print(num)
```
**책의 풀이**
알고리즘 : 최대한 많이나누기 (n이 k의 배수가 될때까지 1씩 빼기, n을 k로 나누기) = 동일

* * *

상하좌우
---
**입력 조건**
* 첫째 줄에 공간의 크기를 나타내는 N이 주어진다.
* 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다.
* 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표(X Y)를 공백으로 구분하여 출력한다.

**나의 풀이**

알고리즘 : dx, dy좌표값과 계획서를 계속 비교하여 그에 해당하는 만큼 좌표를 바꾼다. 만약 1보다 작거나 N보다 크면 무시한다.
```
n = int(input())
darr = input().split()
x=1
y=1

dx=[0,0,-1,1]
dy=[1,-1,0,0]
direc=['R','L','U','D']

for i in range(n):
  for d in range(len(direc)):
    if darr[i]==direc[d]:
      if x+dx[d]<1 or x+dx[d]>n or y+dy[d]<1 or y+dy[d]>n:
        continue
      else:
        x+=dx[d]
        y+=dy[d]

print(x,y)
```
오류 : x값이 하나가 무시되고 진행됨 (ex. U을 두번하면 한번만 진행됨)

**책의 풀이**

알고리즘 : 동일
```
n = int(input())
x, y =1,1
plans=input().split()

dx=[0,0,-1,1]
dy=[-1,1,0,0]
move_type=['L','R','U','D']

for plan in plans :
  for i in range(len(move_type)):
    if plan==move_type[i]:
      nx = x+dx[i]
      ny = y+dy[i]
  if nx<1 or ny<1 or nx>n or ny>n:
    continue
  x, y = nx, ny

print(x, y)
```
* * *

시각
---
**입력조건**
* 첫째줄에 정수 N이 입력된다.
**출력조건**
* 00시 00분 00초부터 N시 59분 59초까지의 모든 시각중에서 3이 하나라도 포함되는 경우의 수를 출력한다.

**나의 풀이**
```
n = int(input())
m, s = 60, 60
num=0

for i in range(n+1):
  for mi in range(m):
    for si in range(s):
      if si//10==3:
        num+=1
      if si%10==3:
        num+=1
      if mi//10==3:
        num+=1
      if mi%10==3:
        num+=1 
      if i//10==3:
        num+=1
      if i%10==3:
        num+=1 

print(num)
```
오류: 결과 값이 5일때 11475가 나와야하는데 15120이 나옴

**책의 풀이**
알고리즘 : 동일
```
n = int(input())
m, s = 60, 60
num=0

for i in range(n+1):
  for mi in range(m):
    for si in range(s):
      if '3' in str(i) + str(mi) + str(si):
        num+=1

print(num)
```
* * *

왕실의 나이트
---
**입력 조건**
* 첫째 줄에 8x8좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자 열이 입력된다. 입력 문자는 a1처럼 열과 행으로 이뤄진다.
* 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력
* (y 좌표는 a,b,c,d,순으로h까지, x좌표는 1부터 8까지)
* 나이트는 2가지 경우로만 이동할 수 있다. ( 수평으로 두칸 이동한 뒤에 수직으로 한칸 이동 or 수직으로 두칸 이동한 뒤에 수평으로 한칸이동)
* 판의 밖으로 나갈 수는 없다.

**알고리즘**
: dx, dy를 해준것과 같은 알고리즘으로 steps을 미리 지정하여 나이트가 움직일 수 있는 좌표를 모두 표시하여 계산한다.
```
inxy = input()
y=int(ord(inxy[0]))-int(ord('a'))+1
x=int(inxy[1])
n=8
num=0

steps=[(-2,1), (-2,-1), (2,1), (2,-1), (-1, 2), (-1, -2), (1,2), (1,-2)]

for i in steps:
  resultX=x+i[1]
  resultY=y+i[0]
  if resultX>=1 and resultX<=n and resultY>=1 and resultY<=n:
    num+=1

print(num)
```

* * *
게임 개발
---
**입력 조건**
* 첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력
* 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (a,b)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다.
* 방향 d는 0:북, 1:동, 2:남, 3:서
* 셋째 줄부터 맵이 육지인지 바다인지 입력한다. 맵의 외각은 항상 바다로 되어있다.
* 0:육지, 1:바다
* 처음 게임 캐릭터가 위치한 칸의 상태는 항상 육지다.

**출력 조건**
* 첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.

**나의 풀이**
```
nX, nY = map(int,input().split())
x, y, d = map(int,input().split())
myMap = []
num=1

for i in range(nX):
  myMap.append(list(map(int,input().split())))

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]
dire = [1, 0, 3, 2]

while True:
  turn_time=0
  for i in dire:
    if d==dire[i]:
      resultX=x+dx[i]
      resultY=y+dy[i]
  if resultX<0 or resultX>nX or resultY<0 or resultY>nY or myMap[resultX][resultY]==1:
    if d==3:
      d=0
    else:
      d+=1
    turn_time+=1
    continue
  else:
    x= resultX
    y= resultY
    num+=1
    if d==3:
      d=0 
    else:
      d+=1
    turn_time+=1
  if turn_time>=4:
    break;

print(num)
```
오류 : 코드 제대로 실행 안됨, 수정 필요
