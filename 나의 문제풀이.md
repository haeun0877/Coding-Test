큰 수의 법칙
---

**입력조건**
* 첫쨰 줄에 N, M, K의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
* 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다.
* 입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력조건**
* 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

-큰 수의 법칙 : ex) N = 2,4,5,4,6 , M = 8, K =3 일때 결과는 6+6+6+5+6+6+6+5=46 으로 46이 된다.

**나의 풀이**

알고리즘 : 리스트를 입력받은 후 내림차순으로 정렬한후 k값만큼 0번째 수를 더하고 k보다 더 많이 입력했을때는 1번째 수를 더하고 다시 k값만큼 0 번쨰 수를 더하는 것을 반복한다.
```
n, m, k = map(int,input().split())
arr = list(map(int,input().split()))
arr.sort(reverse=True)
sum=0
num=1

for i in range(m):
  if num>k:
    sum+=arr[1]
    num=1
    continue
  sum+=arr[0]
  num+=1

print(sum)
```

**책의 풀이**

* 알고리즘1 : 나의 풀이 알고리즘과 동일
* 알고리즘2 : 시간초과 판정을 피할 수 있는 알고리즘 = 가장 큰 수가 더해지는 횟수 = int(M/(K+1))*K+M%(K+1) 를 이용하여 가장 큰 수가 더해지는 횟수를 구한다음, 이를 이용해 두번째로 큰 수가 더해지는 횟수까지 구한다.

=반복되는 수열의 길이 = (K+1), 따라서 M을 (K+1)로 나눈 몫이 수열이 반복되는 횟수, 다시 여기에 K를 곱해주면 가장 큰 수가 등장하는 횟수

=이때 M이 (K+1)로 나누어 떨어지지않는 경우도 고려하여 M을 (K+1)로 나눈 나머지만큼 가장 큰수가 추가로 더해지므로 이를 고려해int(M/(K+1))*K+M%(K+1) 의 식이 나온다

```
n, m, k = map(int, input().split())
data=list(map(int,input().split()))

data.sort()
first=data[n-1]
second=data[n-2]

count = int(m/(k+1))*k
count+=m%(k+1)

result = 0
result+=(count)*first
result+=(m-count)*second

print(result)
```

* * *

숫자 카드 게임
---

**입력조건**
* 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어짐
* 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어짐
* 첫째 줄에 게임의 룰에 맞게 선택한 가드에 적힌 숫자를 출력한다
* 행을 선택하고 그 선택된 행에 포함된 카드중 가장 숫자가 낮은 카드를 뽑는다
* 결과적으로 가장 높은 숫자가 나올수 있는 행을 출력하는 프로그램

**나의 풀이**
알고리즘 : 행별로 각각 가장 낮은 숫자를 고르고 그 숫자들끼리 비교하여 가장 큰 수를 뽑고 그 수의 행을 찾는다. min()함수 사용
```
n, m = map(int, input().split())
minD=0
maxD=0

for i in range(n):
  data = list(map(int, input().split()))
  minD=min(data)
  if minD>maxD:
    maxD=minD

print(maxD)
```

**책의 풀이**
알고리즘1 : min()함수사용 (동일) (max를 비교할때도 max()함수 사용)
알고리즘2 : 2중 반복문 구조를 이용

```
n, m = map(int, input().split())
result=0

for i in range(n):
  data = list(map(int, input().split()))
  min_value=10001
  for a in data:
    min_value = min(min_value, a)
  result = max(result, min_value)

print(result)
```
* * *

1이 될 때까지
---

**입력조건**
* 첫째 줄에 N과 K가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로는 N은 항상 K보다 크거나 같다.
* 첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 횟수의 최솟값 출력
* 1. N에서 1을 뺀다. 2. N을 K로 나눈다.

**나의 풀이**
알고리즘 : N을 K로 나누는 횟수를 최대한 많게하기 위해 -1을 사용하여 N을 K의 배수가 되도록한다.
```
n, k = map(int, input().split())
result=n
num=0

while True:
  num+=1
  if result%k==0:
    result//=k
  else :
    result-=1
  if result==1:
    break;

print(num)
```
**책의 풀이**
알고리즘 : 최대한 많이나누기 (n이 k의 배수가 될때까지 1씩 빼기, n을 k로 나누기) = 동일
